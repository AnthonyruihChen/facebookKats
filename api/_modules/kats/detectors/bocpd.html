
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <!--
    <link rel="alternate" type="application/rss+xml" href="/Kats/blog/rss.xml" title="Kats Blog RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="/Kats/blog/atom.xml" title="Kats Blog Atom Feed">
    -->
    <link rel="preconnect" href="https://www.google-analytics.com">
    <script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-149862507-1","auto"),ga("send","pageview")</script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
    <!--
    <title data-react-helmet="true">Kats | Kats</title>
    <meta data-react-helmet="true" property="og:title" content="Kats | Kats">
    <meta data-react-helmet="true" name="description" content="One stop shop for time series analysis in Python">
    <meta data-react-helmet="true" property="og:description" content="One stop shop for time series analysis in Python">
    <meta data-react-helmet="true" property="og:url" content="https://facebookresearch.github.io/Kats/">
    -->
    <link data-react-helmet="true" rel="shortcut icon" href="/Kats/img/KatsHeroLogo.png">
    <!--
    <link data-react-helmet="true" rel="canonical" href="https://facebookresearch.github.io/Kats/">
    <link data-react-helmet="true" rel="alternate" href="https://facebookresearch.github.io/Kats/" hreflang="en">
    <link data-react-helmet="true" rel="alternate" href="https://facebookresearch.github.io/Kats/" hreflang="x-default">
    -->
    <link rel="stylesheet" href="/Kats/assets/css/styles.99fd060a.css">
    <!--
    <link rel="preload" href="/Kats/assets/js/runtime~main.9e005abd.js" as="script">
    <link rel="preload" href="/Kats/assets/js/main.6382ca5e.js" as="script">
    -->
    </head>


<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>kats.detectors.bocpd &#8212; Kats 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <!--
    <link rel="alternate" type="application/rss+xml" href="/Kats/blog/rss.xml" title="Kats Blog RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="/Kats/blog/atom.xml" title="Kats Blog Atom Feed">
    -->
    <link rel="preconnect" href="https://www.google-analytics.com">
    <script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-149862507-1","auto"),ga("send","pageview")</script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
    <!--
    <title data-react-helmet="true">Kats | Kats</title>
    <meta data-react-helmet="true" property="og:title" content="Kats | Kats">
    <meta data-react-helmet="true" name="description" content="One stop shop for time series analysis in Python">
    <meta data-react-helmet="true" property="og:description" content="One stop shop for time series analysis in Python">
    <meta data-react-helmet="true" property="og:url" content="https://facebookresearch.github.io/Kats/">
    -->
    <link data-react-helmet="true" rel="shortcut icon" href="/Kats/img/KatsHeroLogo.png">
    <!--
    <link data-react-helmet="true" rel="canonical" href="https://facebookresearch.github.io/Kats/">
    <link data-react-helmet="true" rel="alternate" href="https://facebookresearch.github.io/Kats/" hreflang="en">
    <link data-react-helmet="true" rel="alternate" href="https://facebookresearch.github.io/Kats/" hreflang="x-default">
    -->
    <link rel="stylesheet" href="/Kats/assets/css/styles.99fd060a.css">
    <!--
    <link rel="preload" href="/Kats/assets/js/runtime~main.9e005abd.js" as="script">
    <link rel="preload" href="/Kats/assets/js/main.6382ca5e.js" as="script">
    -->
    </head>

  </head><body>
  

    <div class="document">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script>
<!--<div id="__docusaurus">-->
<div id="docusaurus-base-url-issue-banner-container"></div>
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div>
<nav class="navbar navbar--fixed-top">
  <div class="navbar__inner">
      <div class="navbar__items">
          <button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0">
              <svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false">
                  <title>Menu</title>
                  <path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path>
              </svg>
          </button>
          <a class="navbar__brand" href="/Kats/">
              <img src="/Kats/img/KatsHeroLogo.png" alt="Project Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"/>
              <img src="/Kats/img/KatsHeroLogo.png" alt="Project Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"/>
              <strong class="navbar__title">Kats</strong>
          </a>
          <a href="https://facebookresearch.github.io/Kats/api/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">API</a>
          <a href="https://github.com/facebookresearch/Kats/tree/master/tutorials" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Tutorials</a>
      </div>
      <!--
      <div class="navbar__items navbar__items--right">
          <a href="https://github.com/facebookresearch/kats" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Kats@GitHub</a>
          <div class="react-toggle displayOnlyInLargeViewport_GrZ2" role="button" tabindex="-1">
              <div class="react-toggle-track">
                  <div class="react-toggle-track-check">
                      <span class="toggle_71bT">ðŸŒœ</span>
                  </div>
                  <div class="react-toggle-track-x">
                      <span class="toggle_71bT">ðŸŒž</span>
                  </div>
              </div>
              <div class="react-toggle-thumb"></div>
              <input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"/>
          </div>
      </div>
      -->
  </div>
  <div role="presentation" class="navbar-sidebar__backdrop"></div>
  <div class="navbar-sidebar">
      <div class="navbar-sidebar__brand">
          <a class="navbar__brand" href="/Kats/">
              <img src="/Kats/img/KatsHeroLogo.png" alt="Project Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"/>
              <img src="/Kats/img/KatsHeroLogo.png" alt="Project Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"/>
              <strong class="navbar__title">Kats</strong>
          </a>
      </div>
      <div class="navbar-sidebar__items">
          <div class="menu">
              <ul class="menu__list">
                  <li class="menu__list-item">
                      <a href="https://facebookresearch.github.io/Kats/api/" target="_blank" rel="noopener noreferrer" class="menu__link">API</a>
                  </li>
                  <li class="menu__list-item">
                      <a href="https://github.com/facebookresearch/Kats/tree/master/tutorials" target="_blank" rel="noopener noreferrer" class="menu__link">Tutorials</a>
                  </li>
                  <li class="menu__list-item">
                      <a href="https://github.com/facebookresearch/kats" target="_blank" rel="noopener noreferrer" class="menu__link">Kats@GitHub</a>
                  </li>
              </ul>
          </div>
      </div>
  </div>
</nav>
<div class="main-wrapper">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for kats.detectors.bocpd</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="c1"># Copyright (c) Facebook, Inc. and its affiliates.</span>
<span class="c1"># This source code is licensed under the MIT license found in the</span>
<span class="c1"># LICENSE file in the root directory of this source tree.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains classes and functions used for implementing</span>
<span class="sd">the Bayesian Online Changepoint Detection algorithm.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">kats.consts</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TimeSeriesChangePoint</span><span class="p">,</span>
    <span class="n">TimeSeriesData</span><span class="p">,</span>
    <span class="n">SearchMethodEnum</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">kats.utils.time_series_parameter_tuning</span> <span class="k">as</span> <span class="nn">tpt</span>
<span class="kn">from</span> <span class="nn">kats.detectors.detector</span> <span class="kn">import</span> <span class="n">Detector</span>
<span class="c1"># pyre-fixme[21]: Could not find name `invgamma` in `scipy.stats`.</span>
<span class="c1"># pyre-fixme[21]: Could not find name `nbinom` in `scipy.stats`.</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">invgamma</span><span class="p">,</span> <span class="n">linregress</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">nbinom</span>  <span class="c1"># @manual</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">logsumexp</span>  <span class="c1"># @manual</span>

<span class="n">_MIN_POINTS</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">_LOG_SQRT2PI</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>


<div class="viewcode-block" id="BOCPDModelType"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.BOCPDModelType">[docs]</a><span class="k">class</span> <span class="nc">BOCPDModelType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bayesian Online Change Point Detection model type.</span>

<span class="sd">    Describes the type of predictive model used by the</span>
<span class="sd">    BOCPD algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NORMAL_KNOWN_MODEL</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">TREND_CHANGE_MODEL</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">POISSON_PROCESS_MODEL</span> <span class="o">=</span> <span class="mi">3</span></div>


<div class="viewcode-block" id="BOCPDMetadata"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.BOCPDMetadata">[docs]</a><span class="k">class</span> <span class="nc">BOCPDMetadata</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Metadata for the BOCPD model.</span>

<span class="sd">    This gives information about</span>
<span class="sd">    the type of detector, the name of the time series and</span>
<span class="sd">    the model used for detection.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        model: The kind of predictive model used.</span>
<span class="sd">        ts_name: string, name of the time series for which the detector is</span>
<span class="sd">            is being run.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">BOCPDModelType</span><span class="p">,</span> <span class="n">ts_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_detector_type</span> <span class="o">=</span> <span class="n">BOCPDetector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ts_name</span> <span class="o">=</span> <span class="n">ts_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">detector_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detector_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ts_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_name</span></div>


<div class="viewcode-block" id="BOCPDModelParameters"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.BOCPDModelParameters">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">BOCPDModelParameters</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Data class containing data for predictive models used in BOCPD.</span>

<span class="sd">    Particular predictive models derive from this class.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        prior_choice: list of changepoint probability priors</span>
<span class="sd">            over which we will search hyperparameters</span>
<span class="sd">        cp_prior: default prior for probability of changepoint.</span>
<span class="sd">        search_method: string, representing the search method</span>
<span class="sd">            for the hyperparameter tuning library. Allowed values</span>
<span class="sd">            are &#39;random&#39; and &#39;gridsearch&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeriesData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">prior_choice</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;cp_prior&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.002</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">]}</span>
    <span class="p">)</span>

    <span class="n">cp_prior</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">search_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;random&#39;</span>

<div class="viewcode-block" id="BOCPDModelParameters.set_prior"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.BOCPDModelParameters.set_prior">[docs]</a>    <span class="k">def</span> <span class="nf">set_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Setter method, which sets the value of the parameters.</span>

<span class="sd">        Currently, this sets the value of the prior probability of changepoint.</span>

<span class="sd">        Args:</span>
<span class="sd">            param_dict: dictionary of the form {param_name: param_value}.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;cp_prior&#39;</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cp_prior</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;cp_prior&#39;</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="NormalKnownParameters"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.NormalKnownParameters">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">NormalKnownParameters</span><span class="p">(</span><span class="n">BOCPDModelParameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Data class containing the parameters for Normal  predictive model.</span>

<span class="sd">    This assumes that the data comes from a normal distribution with known</span>
<span class="sd">    precision.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        empirical: Boolean, should we derive the prior empirically. When</span>
<span class="sd">            this is true, the mean_prior, mean_prec_prior and known_prec</span>
<span class="sd">            are derived from the data, and don&#39;t need to be specified.</span>
<span class="sd">        mean_prior: float, mean of the prior normal distribution.</span>
<span class="sd">        mean_prec_prior: float, precision of the prior normal distribution.</span>
<span class="sd">        known_prec: float, known precision of the data.</span>
<span class="sd">        known_prec_multiplier: float, a multiplier of the known precision.</span>
<span class="sd">            This is a variable, that is used in the hyperparameter search,</span>
<span class="sd">            to multiply with the known_prec value.</span>
<span class="sd">        prior_choice: List of parameters to search, for hyperparameter tuning.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">empirical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">mean_prior</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mean_prec_prior</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">known_prec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">known_prec_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="n">prior_choice</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span> <span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;known_prec_multiplier&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">],</span>
            <span class="s1">&#39;cp_prior&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.002</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">)</span>

<div class="viewcode-block" id="NormalKnownParameters.set_prior"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.NormalKnownParameters.set_prior">[docs]</a>    <span class="k">def</span> <span class="nf">set_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Sets priors</span>

<span class="sd">        Sets the value of the prior based on the</span>
<span class="sd">        parameter dictionary passed.</span>

<span class="sd">        Args:</span>
<span class="sd">            param_dict: Dictionary of parameters required for</span>
<span class="sd">                setting the prior value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;known_prec_multiplier&#39;</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">known_prec_multiplier</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;known_prec_multiplier&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;cp_prior&#39;</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cp_prior</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;cp_prior&#39;</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="TrendChangeParameters"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.TrendChangeParameters">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">TrendChangeParameters</span><span class="p">(</span><span class="n">BOCPDModelParameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameters for the trend change predictive model.</span>

<span class="sd">    This model assumes that the data is generated from a Bayesian</span>
<span class="sd">    linear model.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        mu_prior: array, mean of the normal priors on the slope and intercept</span>
<span class="sd">        num_likelihood_samples: int, number of samples generated, to calculate</span>
<span class="sd">            the posterior.</span>
<span class="sd">        num_points_prior: int,</span>
<span class="sd">        readjust_sigma_prior: Boolean, whether we should readjust the Inv. Gamma</span>
<span class="sd">        prior for the variance, based on the data.</span>
<span class="sd">        plot_regression_prior: Boolean, plot prior. set as False, unless trying to</span>
<span class="sd">            debug.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mu_prior</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">num_likelihood_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">num_points_prior</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">_MIN_POINTS</span>
    <span class="n">readjust_sigma_prior</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">plot_regression_prior</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="PoissonModelParameters"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.PoissonModelParameters">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PoissonModelParameters</span><span class="p">(</span><span class="n">BOCPDModelParameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameters for the Poisson predictive model.</span>

<span class="sd">    Here, the data is generated from a Poisson distribution.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        alpha_prior: prior value of the alpha value of the Gamma prior.</span>
<span class="sd">        beta_prior: prior value of the beta value of the Gamma prior.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">alpha_prior</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">beta_prior</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span></div>


<div class="viewcode-block" id="BOCPDetector"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.BOCPDetector">[docs]</a><span class="k">class</span> <span class="nc">BOCPDetector</span><span class="p">(</span><span class="n">Detector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bayesian Online Changepoint Detection.</span>

<span class="sd">    Given an univariate time series, this class</span>
<span class="sd">    performs changepoint detection, i.e. it tells</span>
<span class="sd">    us when the time series shows a change. This is online,</span>
<span class="sd">    which means it gives the best estimate based on a</span>
<span class="sd">    lookehead number of time steps (which is the lag).</span>

<span class="sd">    This faithfully implements the algorithm in</span>
<span class="sd">    Adams &amp; McKay, 2007. &quot;Bayesian Online Changepoint Detection&quot;</span>
<span class="sd">    https://arxiv.org/abs/0710.3742</span>

<span class="sd">    The basic idea is to see whether the new values are</span>
<span class="sd">    improbable, when compared to a bayesian predictive model,</span>
<span class="sd">    built from the previous observations.</span>

<span class="sd">    Attrbutes:</span>
<span class="sd">        data: TimeSeriesData, data on which we will run the BOCPD algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">TimeSeriesData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">BOCPDModelType</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="n">_PredictiveModel</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">BOCPDModelType</span><span class="o">.</span><span class="n">NORMAL_KNOWN_MODEL</span><span class="p">:</span> <span class="n">_NormalKnownPrec</span><span class="p">,</span>
            <span class="n">BOCPDModelType</span><span class="o">.</span><span class="n">TREND_CHANGE_MODEL</span><span class="p">:</span> <span class="n">_BayesianLinReg</span><span class="p">,</span>
            <span class="n">BOCPDModelType</span><span class="o">.</span><span class="n">POISSON_PROCESS_MODEL</span><span class="p">:</span> <span class="n">_PoissonProcessModel</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter_type</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">BOCPDModelType</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="n">BOCPDModelParameters</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">BOCPDModelType</span><span class="o">.</span><span class="n">NORMAL_KNOWN_MODEL</span><span class="p">:</span> <span class="n">NormalKnownParameters</span><span class="p">,</span>
            <span class="n">BOCPDModelType</span><span class="o">.</span><span class="n">TREND_CHANGE_MODEL</span><span class="p">:</span> <span class="n">TrendChangeParameters</span><span class="p">,</span>
            <span class="n">BOCPDModelType</span><span class="o">.</span><span class="n">POISSON_PROCESS_MODEL</span><span class="p">:</span> <span class="n">PoissonModelParameters</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">change_prob</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_length_prob</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detected_flag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_type</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Expected equivalent models in .models and .parameter_types, but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_type</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># pyre-fixme[14]: `detector` overrides method defined in `Detector` inconsistently.</span>
    <span class="c1"># pyre-fixme[15]: `detector` overrides method defined in `Detector` inconsistently.</span>
<div class="viewcode-block" id="BOCPDetector.detector"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.BOCPDetector.detector">[docs]</a>    <span class="k">def</span> <span class="nf">detector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">BOCPDModelType</span> <span class="o">=</span> <span class="n">BOCPDModelType</span><span class="o">.</span><span class="n">NORMAL_KNOWN_MODEL</span><span class="p">,</span>
        <span class="n">model_parameters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span> <span class="n">BOCPDModelParameters</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lag</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">choose_priors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">changepoint_prior</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">agg_cp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">TimeSeriesChangePoint</span><span class="p">,</span> <span class="n">BOCPDMetadata</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;The main detector method.</span>

<span class="sd">        This function runs the BOCPD detector</span>
<span class="sd">        and returns the list of changepoints, along with some metadata</span>

<span class="sd">        Args:</span>
<span class="sd">            model: This specifies the probabilistic model, that generates</span>
<span class="sd">                the data within each segment. The user can input several</span>
<span class="sd">                model types depending on the behavior of the time series.</span>
<span class="sd">                Currently allowed models are:</span>
<span class="sd">                NORMAL_KNOWN_MODEL: Normal model with variance known. Use</span>
<span class="sd">                this to find level shifts in normally distributed data.</span>
<span class="sd">                TREND_CHANGE_MODEL : This model assumes each segment is</span>
<span class="sd">                generated from ordinary linear regression. Use this model</span>
<span class="sd">                to understand changes in slope, or trend in time series.</span>
<span class="sd">                POISSON_PROCESS_MODEL: This assumes a poisson generative model.</span>
<span class="sd">                Use this for count data, where most of the values are close</span>
<span class="sd">                to zero.</span>

<span class="sd">            model_parameters: Model Parameters correspond to specific parameters</span>
<span class="sd">                for a specific model. They are defined in the</span>
<span class="sd">                NormalKnownParameters, TrendChangeParameters,</span>
<span class="sd">                PoissonModelParameters classes.</span>

<span class="sd">            lag: integer referring to the lag in reporting the changepoint. We</span>
<span class="sd">                report the changepoint after seeing &quot;lag&quot; number of data points.</span>
<span class="sd">                Higher lag gives greater certainty that this is indeed a changepoint.</span>
<span class="sd">                Lower lag will detect the changepoint faster. This is the tradeoff.</span>

<span class="sd">            choose_priors: If True, then hyperparameter tuning library (HPT) is used</span>
<span class="sd">                to choose the best priors which maximizes the posterior predictive</span>

<span class="sd">            changepoint_prior: This is a Bayesian algorithm. Hence, this parameter</span>
<span class="sd">                specifies the prior belief on the probability</span>
<span class="sd">                that a given point is a changepoint. For example,</span>
<span class="sd">                if you believe 10% of your data will be a changepoint,</span>
<span class="sd">                you can set this to 0.1.</span>

<span class="sd">            threshold: We report the probability of observing the changepoint</span>
<span class="sd">                at each instant. The actual changepoints are obtained by</span>
<span class="sd">                denoting the points above this threshold to be a changepoint.</span>

<span class="sd">            debug: This surfaces additional information, such as the plots of</span>
<span class="sd">                predicted means and variances, which allows the user to see</span>
<span class="sd">                debug why changepoints were not properly detected.</span>

<span class="sd">            agg_cp: It is tested and believed that by aggregating run-length</span>
<span class="sd">                posterior, we may have a stronger signal for changepoint</span>
<span class="sd">                detection. When setting this parameter as True, posterior</span>
<span class="sd">                will be the aggregation of run-length posterior by fetching</span>
<span class="sd">                maximum values diagonally.</span>

<span class="sd">        Returns:</span>
<span class="sd">             List[Tuple[TimeSeriesChangePoint, BOCPDMetadata]]: Each element in this</span>
<span class="sd">             list is a changepoint, an object of TimeSeriesChangepoint class. The start_time</span>
<span class="sd">             gives the time that the change was detected. The metadata contains data about</span>
<span class="sd">             the name of the time series (useful when multiple time series are run simultaneously),</span>
<span class="sd">             and the predictive model used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_models</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Requested model </span><span class="si">{</span><span class="n">model</span><span class="si">}</span><span class="s2"> not currently supported. Please choose one from: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">available_models</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">model_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_type</span><span class="p">[</span><span class="n">model</span><span class="p">]()</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">model_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_type</span><span class="p">[</span><span class="n">model</span><span class="p">]</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Expected parameter type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_type</span><span class="p">[</span><span class="n">model</span><span class="p">]</span><span class="si">}</span><span class="s2">, but got </span><span class="si">{</span><span class="n">model_parameters</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">choose_priors</span><span class="p">:</span>
            <span class="n">changepoint_prior</span><span class="p">,</span> <span class="n">model_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_priors</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">model_parameters</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model_parameters</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_parameters</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Newest model parameters: </span><span class="si">{</span><span class="n">model_parameters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">is_univariate</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">model</span><span class="p">]</span><span class="o">.</span><span class="n">is_multivariate</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Model </span><span class="si">{model.name}</span><span class="s2"> support univariate time series, but get </span><span class="si">{type}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># parameters_dict = dataclasses.asdict(model_parameters)</span>
        <span class="c1"># pyre-fixme[45]: Cannot instantiate abstract class `_PredictiveModel` with `__init__`, `is_multivariate`, `pred_mean` and 4 additional abstract methods.Pyre</span>
        <span class="n">underlying_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">model</span><span class="p">](</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">model_parameters</span><span class="p">)</span>
        <span class="n">underlying_model</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating detector with lag </span><span class="si">{</span><span class="n">lag</span><span class="si">}</span><span class="s2"> and debug option </span><span class="si">{</span><span class="n">debug</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">bocpd</span> <span class="o">=</span> <span class="n">_BayesOnlineChangePoint</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">agg_cp</span><span class="o">=</span><span class="n">agg_cp</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Running .detector() with model </span><span class="si">{</span><span class="n">underlying_model</span><span class="si">}</span><span class="s2">, threshold </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">, changepoint prior </span><span class="si">{</span><span class="n">changepoint_prior</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="n">detector_results_all</span> <span class="o">=</span> <span class="n">bocpd</span><span class="o">.</span><span class="n">detector</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">underlying_model</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
            <span class="n">changepoint_prior</span><span class="o">=</span><span class="n">changepoint_prior</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">detected_flag</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">change_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ts_name</span><span class="p">,</span> <span class="n">detector_results</span> <span class="ow">in</span> <span class="n">detector_results_all</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">change_indices</span> <span class="o">=</span> <span class="n">detector_results</span><span class="p">[</span><span class="s2">&quot;change_points&quot;</span><span class="p">]</span>
            <span class="n">change_probs</span> <span class="o">=</span> <span class="n">detector_results</span><span class="p">[</span><span class="s2">&quot;change_prob&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_prob</span><span class="p">[</span><span class="n">ts_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">change_probs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_run_length_prob</span><span class="p">[</span><span class="n">ts_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">detector_results</span><span class="p">[</span><span class="s2">&quot;run_length_prob&quot;</span><span class="p">]</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Obtained </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">change_indices</span><span class="p">)</span><span class="si">}</span><span class="s2"> change points from underlying model in ts=</span><span class="si">{</span><span class="n">ts_name</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">cp_index</span> <span class="ow">in</span> <span class="n">change_indices</span><span class="p">:</span>
                <span class="n">cp_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">cp_index</span><span class="p">]</span>
                <span class="n">cp</span> <span class="o">=</span> <span class="n">TimeSeriesChangePoint</span><span class="p">(</span>
                    <span class="n">start_time</span><span class="o">=</span><span class="n">cp_time</span><span class="p">,</span>
                    <span class="n">end_time</span><span class="o">=</span><span class="n">cp_time</span><span class="p">,</span>
                    <span class="n">confidence</span><span class="o">=</span><span class="n">change_probs</span><span class="p">[</span><span class="n">cp_index</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">bocpd_metadata</span> <span class="o">=</span> <span class="n">BOCPDMetadata</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">ts_name</span><span class="o">=</span><span class="n">ts_name</span><span class="p">)</span>
                <span class="n">change_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cp</span><span class="p">,</span> <span class="n">bocpd_metadata</span><span class="p">))</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">change_points</span><span class="p">)</span><span class="si">}</span><span class="s2"> change points to client in ts=</span><span class="si">{</span><span class="n">ts_name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">change_points</span></div>

<div class="viewcode-block" id="BOCPDetector.plot"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.BOCPDetector.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">change_points</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">TimeSeriesChangePoint</span><span class="p">,</span> <span class="n">BOCPDMetadata</span><span class="p">]],</span>
        <span class="n">ts_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plots the change points, along with the time series.</span>

<span class="sd">        Use this function to visualize the results of the changepoint detection.</span>

<span class="sd">        Args:</span>
<span class="sd">            change_points: List of changepoints, which are the return value of the detector() function.</span>
<span class="sd">            ts_names: List of names of the time series, useful in case multiple time series are used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO note: Once  D23226664 lands, replace this with self.data.time_col_name</span>
        <span class="n">time_col_name</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>

        <span class="c1"># Group changepoints together</span>
        <span class="n">change_points_per_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_changepoints_by_timeseries</span><span class="p">(</span><span class="n">change_points</span><span class="p">)</span>
        <span class="n">ts_names</span> <span class="o">=</span> <span class="n">ts_names</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">(</span><span class="n">change_points_per_ts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">data_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">ts_name</span> <span class="ow">in</span> <span class="n">ts_names</span><span class="p">:</span>
            <span class="n">ts_changepoints</span> <span class="o">=</span> <span class="n">change_points_per_ts</span><span class="p">[</span><span class="n">ts_name</span><span class="p">]</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data_df</span><span class="p">[</span><span class="n">time_col_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">data_df</span><span class="p">[</span><span class="n">ts_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ts_changepoints</span><span class="p">)</span><span class="si">}</span><span class="s2"> change points for </span><span class="si">{</span><span class="n">ts_name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts_changepoints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No change points detected!&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">change</span> <span class="ow">in</span> <span class="n">ts_changepoints</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">change</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_choose_priors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">BOCPDModelType</span><span class="p">,</span>
                       <span class="n">params</span><span class="p">:</span> <span class="n">BOCPDModelParameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">BOCPDModelParameters</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Chooses priors which are defined by the model parameters.</span>

<span class="sd">        Chooses priors which are defined by the model parameters.</span>
<span class="sd">        All BOCPDModelParameters classes have a changepoint prior to iterate on.</span>
<span class="sd">        Other parameters can be added to specific models.</span>
<span class="sd">        This function runs a parameter search using the hyperparameter tuning library</span>
<span class="sd">        to get the best hyperparameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            model: Type of predictive model.</span>
<span class="sd">            params: Parameters class, containing list of values of the parameters</span>
<span class="sd">            on which to run hyperparameter tuning.</span>

<span class="sd">        Returns:</span>
<span class="sd">            best_cp_prior: best value of the prior on the changepoint probabilities.</span>
<span class="sd">            params: parameter dictionary, where the selected values are set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># test these changepoint_priors</span>
        <span class="n">param_dict</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">prior_choice</span>

        <span class="c1"># which parameter seaching method are we using</span>
        <span class="n">search_method</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">search_method</span>

        <span class="c1"># pick search iterations and method based on definition</span>
        <span class="k">if</span> <span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="n">search_N</span><span class="p">,</span> <span class="n">SearchMethod</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">SearchMethodEnum</span><span class="o">.</span><span class="n">RANDOM_SEARCH_UNIFORM</span>
        <span class="k">elif</span> <span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;gridsearch&#39;</span><span class="p">:</span>
            <span class="n">search_N</span><span class="p">,</span> <span class="n">SearchMethod</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SearchMethodEnum</span><span class="o">.</span><span class="n">GRID_SEARCH</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Search method has to be in random or gridsearch but it is </span><span class="si">{</span><span class="n">search_method</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>

        <span class="c1"># construct the custom parameters for the HPT library</span>
        <span class="n">custom_parameters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
             <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;choice&quot;</span><span class="p">,</span>
             <span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">v</span><span class="p">,</span>
             <span class="s2">&quot;value_type&quot;</span><span class="p">:</span> <span class="s2">&quot;float&quot;</span><span class="p">,</span>
             <span class="s2">&quot;is_ordered&quot;</span><span class="p">:</span> <span class="kc">False</span>
             <span class="p">}</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="n">eval_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_eval_function</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="c1"># Use the HPT library</span>
        <span class="n">seed_value</span> <span class="o">=</span> <span class="mi">100</span>

        <span class="n">ts_tuner</span> <span class="o">=</span> <span class="n">tpt</span><span class="o">.</span><span class="n">SearchMethodFactory</span><span class="o">.</span><span class="n">create_search_method</span><span class="p">(</span>
            <span class="n">parameters</span><span class="o">=</span><span class="n">custom_parameters</span><span class="p">,</span>
            <span class="n">selected_search_method</span><span class="o">=</span><span class="n">SearchMethod</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed_value</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">search_N</span><span class="p">):</span>
            <span class="n">ts_tuner</span><span class="o">.</span><span class="n">generate_evaluate_new_parameter_values</span><span class="p">(</span>
                <span class="n">evaluation_function</span><span class="o">=</span><span class="n">eval_fn</span><span class="p">,</span> <span class="n">arm_count</span><span class="o">=</span><span class="mi">4</span>
            <span class="p">)</span>

        <span class="n">scores_df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ts_tuner</span><span class="o">.</span><span class="n">list_parameter_value_scores</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="n">scores_df</span> <span class="o">=</span> <span class="n">scores_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">best_params</span> <span class="o">=</span> <span class="n">scores_df</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">params</span><span class="o">.</span><span class="n">set_prior</span><span class="p">(</span><span class="n">best_params</span><span class="p">)</span>

        <span class="n">best_cp_prior</span> <span class="o">=</span> <span class="n">best_params</span><span class="p">[</span><span class="s1">&#39;cp_prior&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">best_cp_prior</span><span class="p">,</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">_get_eval_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">BOCPDModelType</span><span class="p">,</span>
                           <span class="n">model_parameters</span><span class="p">:</span> <span class="n">BOCPDModelParameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        generates the objective function evaluated by hyperparameter</span>
<span class="sd">        tuning library for choosing the priors</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">eval_fn</span><span class="p">(</span><span class="n">params_to_eval</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="n">changepoint_prior</span> <span class="o">=</span> <span class="n">params_to_eval</span><span class="p">[</span><span class="s1">&#39;cp_prior&#39;</span><span class="p">]</span>
            <span class="n">model_parameters</span><span class="o">.</span><span class="n">set_prior</span><span class="p">(</span><span class="n">params_to_eval</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">model_parameters</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">params_to_eval</span><span class="p">)</span>
            <span class="c1"># pyre-fixme[45]: Cannot instantiate abstract class `_PredictiveModel` with `__init__`, `is_multivariate`, `pred_mean` and 4 additional abstract methods.Pyre</span>
            <span class="n">underlying_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">model</span><span class="p">](</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">model_parameters</span><span class="p">)</span>
            <span class="n">change_point</span> <span class="o">=</span> <span class="n">_BayesOnlineChangePoint</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">change_point</span><span class="o">.</span><span class="n">detector</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">underlying_model</span><span class="p">,</span>
                                  <span class="n">changepoint_prior</span><span class="o">=</span><span class="n">changepoint_prior</span><span class="p">,</span>
                                  <span class="n">threshold</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
            <span class="n">post_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">change_point</span><span class="o">.</span><span class="n">get_posterior_predictive</span><span class="p">())</span>

            <span class="k">return</span> <span class="n">post_pred</span>

        <span class="k">return</span> <span class="n">eval_fn</span>

<div class="viewcode-block" id="BOCPDetector.group_changepoints_by_timeseries"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.BOCPDetector.group_changepoints_by_timeseries">[docs]</a>    <span class="k">def</span> <span class="nf">group_changepoints_by_timeseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">change_points</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">TimeSeriesChangePoint</span><span class="p">,</span> <span class="n">BOCPDMetadata</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">TimeSeriesChangePoint</span><span class="p">,</span> <span class="n">BOCPDMetadata</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Helper function to group changepoints by time series.</span>

<span class="sd">        For multivariate inputs, all changepoints are output in</span>
<span class="sd">        a list and the time series they correspond to is referenced</span>
<span class="sd">        in the metadata. This function is a helper function to</span>
<span class="sd">        group these changepoints by time series.</span>

<span class="sd">        Args:</span>
<span class="sd">            change_points: List of changepoints, with metadata containing the time</span>
<span class="sd">                series names. This is the return value of the detector() method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary, with time series names, and their corresponding changepoints.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">is_univariate</span><span class="p">():</span>
            <span class="n">data_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
            <span class="n">ts_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Multivariate</span>
            <span class="n">ts_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">columns</span>

        <span class="n">change_points_per_ts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ts_name</span> <span class="ow">in</span> <span class="n">ts_names</span><span class="p">:</span>
            <span class="n">change_points_per_ts</span><span class="p">[</span><span class="n">ts_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">change_points</span><span class="p">:</span>
            <span class="n">change_points_per_ts</span><span class="p">[</span><span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ts_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">change_points_per_ts</span><span class="p">)</span></div>

<div class="viewcode-block" id="BOCPDetector.get_change_prob"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.BOCPDetector.get_change_prob">[docs]</a>    <span class="k">def</span> <span class="nf">get_change_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns the probability of being a changepoint.</span>

<span class="sd">        Args:</span>
<span class="sd">            None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            For every point in the time series. The return</span>
<span class="sd">            type is a dict, with the name of the timeseries</span>
<span class="sd">            as the key, and the value is an array of probabilities</span>
<span class="sd">            of the same length as the timeseries data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">detected_flag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;detector needs to be run before getting prob&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">change_prob</span></div>

<div class="viewcode-block" id="BOCPDetector.get_run_length_matrix"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.BOCPDetector.get_run_length_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_run_length_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns the entire run-time posterior.</span>
<span class="sd">        Args:</span>
<span class="sd">            None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The return type is a dict, with the name of the timeseries</span>
<span class="sd">            as the key, and the value is an array of probabilities</span>
<span class="sd">            of the same length as the timeseries data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">detected_flag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;detector needs to be run before getting prob&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_length_prob</span></div></div>


<span class="k">class</span> <span class="nc">_BayesOnlineChangePoint</span><span class="p">(</span><span class="n">Detector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The underlying implementation of the BOCPD algorithm.</span>

<span class="sd">    This is called by the class BayesianOnlineChangepoint. The user should</span>
<span class="sd">    call the top level class, and not this one.</span>

<span class="sd">    Given an univariate time series, this class</span>
<span class="sd">    performs changepoint detection, i.e. it tells</span>
<span class="sd">    us when the time series shows a change. This is online,</span>
<span class="sd">    which means it gives the best estimate based on a</span>
<span class="sd">    lookehead number of time steps (which is the lag).</span>

<span class="sd">    This faithfully implements the algorithm in</span>
<span class="sd">    Adams &amp; McKay, 2007. &quot;Bayesian Online Changepoint Detection&quot;</span>
<span class="sd">    https://arxiv.org/abs/0710.3742</span>

<span class="sd">    The basic idea is to see whether the new values are</span>
<span class="sd">    improbable, when compared to a bayesian predictive model,</span>
<span class="sd">    built from the previous observations.</span>

<span class="sd">    Attributes::</span>
<span class="sd">    data: This is univariate time series data. We require more</span>
<span class="sd">        than 10 points, otherwise it is not very meaningful to define</span>
<span class="sd">        changepoints.</span>

<span class="sd">    T: number of values in the time series data.</span>

<span class="sd">    lag: This specifies, how many time steps we will look ahead to</span>
<span class="sd">        determine the change. There is a tradeoff in setting this parameter.</span>
<span class="sd">        A small lag means we can detect a change really fast, which is important</span>
<span class="sd">        in many applications. However, this also means we will make more</span>
<span class="sd">        mistakes/have lower confidence since we might mistake a spike for change.</span>

<span class="sd">    threshold: Threshold between 0 and 1. Probability values above this threshold</span>
<span class="sd">        will be denoted as changepoint.</span>

<span class="sd">    debug: This is a boolean. If set to true, this shows additional plots.</span>
<span class="sd">        Currently, it shows a plot of the predicted mean and variance, after</span>
<span class="sd">        lag steps, and the predictive probability of the next point. If the</span>
<span class="sd">        results are unusual, the user should set it to true in order to</span>
<span class="sd">        debug.</span>

<span class="sd">    agg_cp: It is tested and believed that by aggregating run-length</span>
<span class="sd">        posterior, we may have a stronger signal for changepoint</span>
<span class="sd">        detection. When setting this parameter as True, posterior</span>
<span class="sd">        will be the aggregation of run-length posterior by fetching</span>
<span class="sd">        maximum values diagonally.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rt_posterior</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pred_mean_arr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pred_std_arr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">next_pred_prob</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">TimeSeriesData</span><span class="p">,</span> <span class="n">lag</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">agg_cp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag</span> <span class="o">=</span> <span class="n">lag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agg_cp</span> <span class="o">=</span> <span class="n">agg_cp</span>
        <span class="c1"># We use tensors for all data throughout; if the data is univariate</span>
        <span class="c1"># then the last dimension is trivial. In this way, we standardise</span>
        <span class="c1"># the same calculation throughout with fewer additional checks</span>
        <span class="c1"># for univariate and bivariate data.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">is_univariate</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Number of time series</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ts_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">columns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_values</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">data_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ts_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;time&#39;</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">data_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">posterior_predictive</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_posterior_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_message_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>

    <span class="c1"># pyre-fixme[14]: `detector` overrides method defined in `Detector` inconsistently.</span>
    <span class="c1"># pyre-fixme[15]: `detector` overrides method defined in `Detector` inconsistently.</span>
    <span class="k">def</span> <span class="nf">detector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">changepoint_prior</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Runs the actual BOCPD detection algorithm.</span>

<span class="sd">        Args:</span>
<span class="sd">            model: Predictive Model for BOCPD</span>
<span class="sd">            threshold: values between 0 and 1, array since this can be specified</span>
<span class="sd">                separately for each time series.</span>
<span class="sd">            changepoint_prior: array, each element between 0 and 1. Each element</span>
<span class="sd">                specifies the prior probability of observing a changepoint</span>
<span class="sd">                in each time series.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary, with key as the name of the time series, and value containing</span>
<span class="sd">            list of change points and their probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">changepoint_prior</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">changepoint_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">changepoint_prior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rt_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_posterior</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">changepoint_prior</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_posterior_predictive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the posterior predictive.</span>

<span class="sd">        This is  sum_{t=1}^T P(x_{t+1}|x_{1:t})</span>

<span class="sd">        Args:</span>
<span class="sd">            None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array of predicted log probabilities for the next point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">posterior_predictive</span>

    <span class="k">def</span> <span class="nf">_find_posterior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">changepoint_prior</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This calculates the posterior distribution over changepoints.</span>
<span class="sd">        The steps here are the same as the algorithm described in</span>
<span class="sd">        Adams &amp; McKay, 2007. https://arxiv.org/abs/0710.3742</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># P(r_t|x_t)</span>
        <span class="n">rt_posterior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_posterior_shape</span><span class="p">)</span>

        <span class="c1"># initialize first step</span>
        <span class="c1"># P(r_0=1) = 1</span>
        <span class="n">rt_posterior</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">model</span><span class="o">.</span><span class="n">update_sufficient_stats</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">])</span>
        <span class="c1"># To avoid growing a large dynamic list, we construct a large</span>
        <span class="c1"># array and grow the array backwards from the end.</span>
        <span class="c1"># This is conceptually equivalent to array, which we insert/append</span>
        <span class="c1"># to the beginning - but avoids reallocating memory.</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_message_shape</span><span class="p">)</span>
        <span class="n">m_ptr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># set up arrays for debugging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred_mean_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_posterior_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred_std_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_posterior_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_pred_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_posterior_shape</span><span class="p">)</span>

        <span class="c1"># Calculate the log priors once outside the for-loop.</span>
        <span class="n">log_cp_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">changepoint_prior</span><span class="p">)</span>
        <span class="n">log_om_cp_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">changepoint_prior</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">posterior_predictive</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">log_posterior</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># from the second step onwards</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">this_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">]</span>

            <span class="c1"># P(x_t | r_t-1, x_t^r)</span>
            <span class="c1"># this arr has a size of t, each element says what is the predictive prob.</span>
            <span class="c1"># of a point, it the current streak began at t</span>
            <span class="c1"># Step 3 of paper</span>
            <span class="n">pred_arr</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_prob</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">this_pt</span><span class="p">)</span>

            <span class="c1"># Step 9 posterior predictive</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">posterior_predictive</span> <span class="o">+=</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">pred_arr</span> <span class="o">+</span> <span class="n">log_posterior</span><span class="p">)</span>

            <span class="c1"># record the mean/variance/prob for debugging</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="n">pred_mean</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_mean</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">this_pt</span><span class="p">)</span>
                <span class="n">pred_std</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_std</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">this_pt</span><span class="p">)</span>
                <span class="c1"># pyre-fixme[16]: `Optional` has no attribute `__setitem__`.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pred_mean_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred_mean</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pred_std_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred_std</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">next_pred_prob</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred_arr</span>

            <span class="c1"># calculate prob that this is a changepoint, i.e. r_t = 0</span>
            <span class="c1"># step 5 of paper</span>
            <span class="c1"># this is elementwise multiplication of pred and message</span>
            <span class="n">log_change_point_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                <span class="n">pred_arr</span> <span class="o">+</span> <span class="n">message</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">m_ptr</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">]</span> <span class="o">+</span> <span class="n">log_cp_prior</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

            <span class="c1"># step 4</span>
            <span class="c1"># log_growth_prob = pred_arr + message + np.log(1.0 - changepoint_prior)</span>
            <span class="n">message</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">m_ptr</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">pred_arr</span> <span class="o">+</span> <span class="n">message</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">m_ptr</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">]</span> <span class="o">+</span> <span class="n">log_om_cp_prior</span>
            <span class="p">)</span>

            <span class="c1"># P(r_t, x_1:t)</span>
            <span class="c1"># log_joint_prob = np.append(log_change_point_prob, log_growth_prob)</span>
            <span class="n">m_ptr</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">message</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">m_ptr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_change_point_prob</span>

            <span class="c1"># calculate evidence, step 6</span>
            <span class="c1"># (P(x_1:t))</span>
            <span class="c1"># log_evidence = logsumexp(log_joint_prob)</span>
            <span class="c1">#</span>
            <span class="c1"># We use two facts here to make this more efficient:</span>
            <span class="c1">#</span>
            <span class="c1">#    (1) log(e^(x_1+c) + ... + e^(x_n+c))</span>
            <span class="c1">#            = log(e^c . (e^(x_1) + ... + e^(x_n)))</span>
            <span class="c1">#            = c + log(e^(x_1) + ... + e^(x_n))</span>
            <span class="c1">#</span>
            <span class="c1">#    (2) log(e^x_1 + e^x_2 + ... + e^x_n)                        [Associativity of logsumexp]</span>
            <span class="c1">#            = log(e^x_1 + e^(log(e^x_2 + ... + e^x_n)))</span>
            <span class="c1">#</span>
            <span class="c1"># In particular, we rewrite:</span>
            <span class="c1">#</span>
            <span class="c1">#    (5)   logaddexp_vec(pred_arr + message + log_cp_prior)</span>
            <span class="c1">#    (4+6) logaddexp_vec(append(log_change_point_prob, pred_arr + message + log_om_cp_prior))</span>
            <span class="c1">#</span>
            <span class="c1"># to</span>
            <span class="c1">#</span>
            <span class="c1">#    M = logaddexp_vector(pred_arr + message) + log_cp_prior     (using (1))</span>
            <span class="c1">#    logaddexp_binary(                                           (using (2))</span>
            <span class="c1">#        log_change_point_prob,</span>
            <span class="c1">#        M - log_cp_prior + log_om_cp_prior                      (using (1))</span>
            <span class="c1">#     )</span>
            <span class="c1">#</span>
            <span class="c1"># In this way, we avoid up to T expensive log and exp calls by avoiding</span>
            <span class="c1"># the repeated calculation of logaddexp_vector(pred_arr + message)</span>
            <span class="c1"># while adding in only a single binary (not T length) logsumexp</span>
            <span class="c1"># call in return and some fast addition and multiplications.</span>
            <span class="n">log_evidence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">(</span>
                <span class="n">log_change_point_prob</span><span class="p">,</span>
                <span class="n">log_change_point_prob</span> <span class="o">-</span> <span class="n">log_cp_prior</span> <span class="o">+</span> <span class="n">log_om_cp_prior</span>
            <span class="p">)</span>

            <span class="c1"># step 7</span>
            <span class="c1"># log_posterior = log_joint_prob - log_evidence</span>
            <span class="n">log_posterior</span> <span class="o">=</span> <span class="n">message</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">m_ptr</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_evidence</span>
            <span class="n">rt_posterior</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_posterior</span><span class="p">)</span>

            <span class="c1"># step 8</span>
            <span class="n">model</span><span class="o">.</span><span class="n">update_sufficient_stats</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">this_pt</span><span class="p">)</span>

            <span class="c1"># pass the joint as a message to next step</span>
            <span class="c1"># message = log_joint_prob</span>
            <span class="c1"># Message is now passed implicitly - as we set it directly above.</span>

        <span class="k">return</span> <span class="n">rt_posterior</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ts_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the changepoints along with the timeseries.</span>

<span class="sd">        Args:</span>
<span class="sd">            threshold: between 0 and 1. probability values above the threshold will be</span>
<span class="sd">                determined to be changepoints.</span>
<span class="sd">            lag: lags to use. If None, use the lags this was initialized with.</span>
<span class="sd">            ts_names: list of names of the time series. Useful when there are multiple</span>
<span class="sd">                time series.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span>

        <span class="k">if</span> <span class="n">lag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag</span>

        <span class="c1"># do some work to define the changepoints</span>
        <span class="n">cp_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_output</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ts_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ts_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_names</span>

        <span class="k">for</span> <span class="n">ts_ix</span><span class="p">,</span> <span class="n">ts_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts_names</span><span class="p">):</span>
            <span class="n">cp_output</span> <span class="o">=</span> <span class="n">cp_outputs</span><span class="p">[</span><span class="n">ts_name</span><span class="p">]</span>
            <span class="n">change_points</span> <span class="o">=</span> <span class="n">cp_output</span><span class="p">[</span><span class="s2">&quot;change_points&quot;</span><span class="p">]</span>
            <span class="n">ts_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">ts_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_min_cpplot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts_values</span><span class="p">)</span>
            <span class="n">y_max_cpplot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts_values</span><span class="p">)</span>

            <span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

            <span class="c1"># Plot the time series</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
            <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>

            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="n">ts_values</span><span class="p">,</span> <span class="s2">&quot;r-&quot;</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Values&quot;</span><span class="p">)</span>

            <span class="c1"># plot change points on the time series</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">change_points</span><span class="p">,</span>
                <span class="n">ymin</span><span class="o">=</span><span class="n">y_min_cpplot</span><span class="p">,</span>
                <span class="n">ymax</span><span class="o">=</span><span class="n">y_max_cpplot</span><span class="p">,</span>
                <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span>
                <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># if in debugging mode, plot the mean and variance as well</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="n">x_debug</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                <span class="c1"># pyre-fixme[16]: `Optional` has no attribute `__getitem__`.</span>
                <span class="n">y_debug_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_mean_arr</span><span class="p">[</span><span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">ts_ix</span><span class="p">]</span>
                <span class="n">y_debug_uv</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pred_mean_arr</span><span class="p">[</span><span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">ts_ix</span><span class="p">]</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_std_arr</span><span class="p">[</span><span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">ts_ix</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="n">y_debug_lv</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pred_mean_arr</span><span class="p">[</span><span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">ts_ix</span><span class="p">]</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_std_arr</span><span class="p">[</span><span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">ts_ix</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_debug</span><span class="p">,</span> <span class="n">y_debug_mean</span><span class="p">,</span> <span class="s2">&quot;k-&quot;</span><span class="p">)</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_debug</span><span class="p">,</span> <span class="n">y_debug_uv</span><span class="p">,</span> <span class="s2">&quot;k--&quot;</span><span class="p">)</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_debug</span><span class="p">,</span> <span class="n">y_debug_lv</span><span class="p">,</span> <span class="s2">&quot;k--&quot;</span><span class="p">)</span>

            <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>

            <span class="n">cp_plot_x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">lag</span><span class="p">))</span>
            <span class="n">cp_plot_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rt_posterior</span><span class="p">[</span><span class="n">lag</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">ts_ix</span><span class="p">])</span>
            <span class="c1"># handle the fact that first point is not a changepoint</span>
            <span class="n">cp_plot_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp_plot_x</span><span class="p">,</span> <span class="n">cp_plot_y</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Changepoint Probability&quot;</span><span class="p">)</span>

            <span class="c1"># if debugging, we also want to show the predictive probabities</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">next_pred_prob</span><span class="p">[</span><span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">ts_ix</span><span class="p">],</span>
                    <span class="s2">&quot;k-&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Log Prob. Density Function&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Debugging: Predicted Probabilities&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_agg_cppprob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">rt_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt_posterior</span>
        <span class="k">assert</span> <span class="n">rt_posterior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">run_length_pos</span> <span class="o">=</span> <span class="n">rt_posterior</span><span class="p">[:,:,</span><span class="n">t</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">run_length_pos</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">change_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">change_prob</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">run_length_pos</span><span class="p">[</span><span class="n">i</span><span class="p">:,:(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">change_prob</span>

    <span class="k">def</span> <span class="nf">_construct_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">lag</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">rt_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt_posterior</span>
        <span class="k">assert</span> <span class="n">rt_posterior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">t_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ts_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg_cp</span><span class="p">:</span>
                <span class="c1"># till lag, prob = 0, so prepend array with zeros</span>
                <span class="n">change_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rt_posterior</span><span class="p">[</span><span class="n">lag</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lag</span><span class="p">)))</span>
                <span class="c1"># handle the fact that the first point is not a changepoint</span>
                <span class="n">change_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg_cp</span><span class="p">:</span>
                <span class="n">change_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_agg_cppprob</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="n">change_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">change_prob</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">[</span><span class="n">t</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="n">t_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;change_prob&quot;</span><span class="p">:</span> <span class="n">change_prob</span><span class="p">,</span>
                <span class="s2">&quot;change_points&quot;</span><span class="p">:</span> <span class="n">change_points</span><span class="p">,</span>
                <span class="s2">&quot;run_length_prob&quot;</span><span class="p">:</span> <span class="n">rt_posterior</span><span class="p">[:,:,</span><span class="n">t</span><span class="p">]</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">lag</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Adjust the parameters.</span>

<span class="sd">        If the preset parameters are not giving the desired result,</span>
<span class="sd">        the user can adjust the parameters. Since the algorithm</span>
<span class="sd">        calculates changepoints for all lags, we can see how</span>
<span class="sd">        changepoints look like for other lag/threshold.</span>

<span class="sd">        Args:</span>
<span class="sd">            threshold: between 0 and 1. Probabilities above threshold are</span>
<span class="sd">                considered to be changepoints.</span>
<span class="sd">            lag: lag at which changepoints are calculated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            cp_output: Dictionary with changepoint list and probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cp_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_output</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cp_output</span>


<div class="viewcode-block" id="check_data"><a class="viewcode-back" href="../../../kats.detectors.bocpd.html#kats.detectors.bocpd.check_data">[docs]</a><span class="k">def</span> <span class="nf">check_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">TimeSeriesData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Small helper function to check if the data is in the appropriate format.</span>

<span class="sd">    Currently, this only checks if we have enough data points to run the</span>
<span class="sd">    algorithm meaningfully.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: TimeSeriesData object, on which to run the algorithm.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">_MIN_POINTS</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            Data must have </span><span class="si">{</span><span class="n">_MIN_POINTS</span><span class="si">}</span><span class="s2"> points,</span>
<span class="s2">            it only has </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> points</span>
<span class="s2">            &quot;&quot;&quot;</span>
        <span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_PredictiveModel</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for BOCPD Predictive models.</span>

<span class="sd">    This is an abstract class. All Predictive models</span>
<span class="sd">    for BOCPD derive from this class.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        data: TimeSeriesdata object we are modeling.</span>
<span class="sd">        parameters: Parameter class, which contains BOCPD model parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">TimeSeriesData</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">BOCPDModelParameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">pred_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">pred_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">pred_std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">update_sufficient_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">is_multivariate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">_NormalKnownPrec</span><span class="p">(</span><span class="n">_PredictiveModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Predictive model where data comes from a Normal distribution.</span>

<span class="sd">    This model is the Normal-Normal model, with known precision</span>
<span class="sd">    It is specified in terms of precision for convenience.</span>
<span class="sd">    It assumes that the data is generated from a normal distribution with</span>
<span class="sd">    known precision.</span>
<span class="sd">    The prior on the mean of the normal, is a normal distribution.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        data: The Timeseriesdata object, for which the algorithm is run.</span>
<span class="sd">        parameters: Parameters specifying the prior.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">TimeSeriesData</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">NormalKnownParameters</span>
    <span class="p">):</span>

        <span class="c1"># \mu \sim N(\mu0, \frac{1}{\lambda0})</span>
        <span class="c1"># x \sim N(\mu,\frac{1}{\lambda})</span>

        <span class="n">empirical</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">empirical</span>
        <span class="n">mean_prior</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mean_prior</span>
        <span class="n">mean_prec_prior</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mean_prec_prior</span>
        <span class="n">known_prec</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">known_prec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># hyper parameters for mean and precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span> <span class="o">=</span> <span class="n">mean_prior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_0</span> <span class="o">=</span> <span class="n">mean_prec_prior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span> <span class="o">=</span> <span class="n">known_prec</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">is_univariate</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Multivariate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># If the user didn&#39;t specify the priors as multivariate</span>
            <span class="c1"># then we assume the same prior(s) over all time series.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambda_0</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lambda_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambda_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>



        <span class="c1"># For efficiency, we simulate a dynamically growing list with</span>
        <span class="c1"># insertions at the start, by a fixed size array with a pointer</span>
        <span class="c1"># where we grow the array from the end of the array. This</span>
        <span class="c1"># makes insertions constant time and means we can use</span>
        <span class="c1"># vectorized computation throughout.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># if priors are going to be decided empirically,</span>
        <span class="c1"># we ignore these settings above</span>
        <span class="c1"># Also, we need to pass on the data in this case</span>
        <span class="k">if</span> <span class="n">empirical</span><span class="p">:</span>
            <span class="n">check_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_find_empirical_prior</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We set these here to avoid recomputing the linear expression</span>
            <span class="c1"># throughout + avoid unnecessarily zeroing the memory etc.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prec_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambda_0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Priors for NormalKnownPrec should not be None.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># everything is already set up in __init__!</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_find_empirical_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">TimeSeriesData</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if priors are not defined, we take an empirical Bayes</span>
<span class="sd">        approach and define the priors from the data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data_arr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># best guess of mu0 is data mean</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">is_univariate</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span> <span class="o">=</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span> <span class="o">=</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># variance of the mean: \lambda_0 = \frac{N}{\sigma^2}</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">is_univariate</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lambda_0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lambda_0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># to find the variance of the data we just look at small</span>
        <span class="c1"># enough windows such that the mean won&#39;t change between</span>
        <span class="n">window_size</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">var_arr</span> <span class="o">=</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">()[</span><span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">is_univariate</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">known_prec_multiplier</span> <span class="o">/</span> <span class="n">var_arr</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">known_prec_multiplier</span> <span class="o">/</span> <span class="n">var_arr</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Empirical Prior: mu_0:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_0</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Empirical Prior: lambda_0:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_0</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Empirical Prior: lambda_val:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_norm_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hardcoded version of scipy.norm.logpdf.</span>
<span class="sd">        This is hardcoded because scipy version is slow due to checks +</span>
<span class="sd">        uses log(pdf(...)) - which wastefully computes exp(..) and log(...).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">std</span><span class="p">)</span> <span class="o">-</span> <span class="n">_LOG_SQRT2PI</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">pred_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns log predictive probabilities.</span>

<span class="sd">        We will give log predictive probabilities for</span>
<span class="sd">        changepoints that started at times from 0 to t.</span>

<span class="sd">        This posterior predictive is from</span>
<span class="sd">        https://www.cs.ubc.ca/~murphyk/Papers/bayesGauss.pdf</span>
<span class="sd">        equation 36.</span>

<span class="sd">        Args:</span>
<span class="sd">            t is the time,</span>
<span class="sd">            x is the new data point</span>

<span class="sd">        Returns:</span>
<span class="sd">            pred_arr: Array with predicted log probabilities for each starting point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pred_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm_logpdf</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="o">+</span> <span class="n">t</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="o">+</span> <span class="n">t</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_arr</span>

    <span class="k">def</span> <span class="nf">pred_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="o">+</span> <span class="n">t</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">pred_std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="o">+</span> <span class="n">t</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update_sufficient_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Updates sufficient statistics with new data.</span>

<span class="sd">        We will store the sufficient stats for</span>
<span class="sd">        a streak starting at times 0, 1, ....t.</span>

<span class="sd">        This is eqn 29 and 30 in Kevin Murphy&#39;s note:</span>
<span class="sd">                https://www.cs.ubc.ca/~murphyk/Papers/bayesGauss.pdf</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The new data point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># \lambda = \lambda_0 + n * \lambda</span>
        <span class="c1"># hence, online, at each step: lambda[i] = lambda[i-1] + 1* lambda</span>

        <span class="c1"># for numerator of the mean.</span>
        <span class="c1"># n*\bar{x}*\lambda + \mu_0 * \lambda_0</span>

        <span class="c1"># So, online we add x*\lambda to the numerator from the previous step</span>

        <span class="c1"># I think we can do it online, but I will need to think more</span>
        <span class="c1"># for now we&#39;ll just keep track of the sum</span>

        <span class="c1"># Grow list (backwards from the end of the array for efficiency)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># update the precision array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prec_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span>

        <span class="c1"># update the numerator of the mean array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr_num</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span>

        <span class="c1"># This is now handled by initializing the array with this value.</span>
        <span class="c1"># self._prec_arr[self._ptr] = self.lambda_0 + 1. * self.lambda_val</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prec_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span>
        <span class="p">)</span>

        <span class="c1"># This is now handled by initializing the array with self.mu_0 * self.lambda_0</span>
        <span class="c1"># self._mean_arr_num[self._ptr] = (x * self.lambda_val + self.mu_0 * self.lambda_0)</span>

        <span class="c1"># update the mean array itself</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr_num</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span><span class="p">]</span>
            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prec_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptr</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxT</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_multivariate</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">_BayesianLinReg</span><span class="p">(</span><span class="n">_PredictiveModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Predictive model for BOCPD where data comes from linear model.</span>

<span class="sd">    Defines the predictive model, where we assume that the data points</span>
<span class="sd">    come from a Bayesian Linear model, where the values are regressed</span>
<span class="sd">    against time.</span>
<span class="sd">    We use a conjugate prior, where we impose an Inverse gamma prior on</span>
<span class="sd">    sigma^2 and normal prior on the conditional distribution of beta</span>
<span class="sd">    p(beta|sigma^2)</span>
<span class="sd">    See https://en.wikipedia.org/wiki/Bayesian_linear_regression</span>
<span class="sd">    for the calculations.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        data: TimeSeriesData object, on which algorithm is run</span>
<span class="sd">        parameters: Specifying all the priors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mu_prior</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">prior_regression_numpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">TimeSeriesData</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">TrendChangeParameters</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">mu_prior</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mu_prior</span>
        <span class="n">num_likelihood_samples</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">num_likelihood_samples</span>
        <span class="n">num_points_prior</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">num_points_prior</span>
        <span class="n">readjust_sigma_prior</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">readjust_sigma_prior</span>
        <span class="n">plot_regression_prior</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">plot_regression_prior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Initializing bayesian linear regression with data </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;mu_prior </span><span class="si">{</span><span class="n">mu_prior</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_likelihood_samples</span><span class="si">}</span><span class="s2"> likelihood samples, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num_points_prior</span><span class="si">}</span><span class="s2"> points to run basic linear regression with, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;sigma prior adjustment </span><span class="si">{</span><span class="n">readjust_sigma_prior</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;and plot prior regression </span><span class="si">{</span><span class="n">plot_regression_prior</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Random numbers I tried out to make the sigma_squared values really large</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_0</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># TODO find better priors?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_0</span> <span class="o">=</span> <span class="mi">200</span>  <span class="c1"># TODO</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_vals</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_prior</span> <span class="o">=</span> <span class="mf">2e-7</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_likelihood_samples</span> <span class="o">=</span> <span class="n">num_likelihood_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_sum_samples</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_likelihood_samples</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span>
        <span class="p">)</span>  <span class="c1"># TODO: Hack for getting around probabilities of 0 -- cap it at some minimum</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets up the regression, by calculating the priors.</span>

<span class="sd">        Args:</span>
<span class="sd">            None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">mu_prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mu_prior</span>
        <span class="n">num_points_prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">num_points_prior</span>
        <span class="n">readjust_sigma_prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">readjust_sigma_prior</span>
        <span class="n">plot_regression_prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">plot_regression_prior</span>

        <span class="c1"># Set up linear regression prior</span>
        <span class="k">if</span> <span class="n">mu_prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prior_regression_numpoints</span> <span class="o">=</span> <span class="n">num_points_prior</span>

                <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_time</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_regression_numpoints</span><span class="p">]</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_vals</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_regression_numpoints</span><span class="p">]</span>

                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Running basic linear regression.&quot;</span><span class="p">)</span>

                <span class="c1"># Compute basic linear regression</span>
                <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="n">linregress</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mu_prior</span> <span class="o">=</span> <span class="n">mu_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span><span class="p">])</span>  <span class="c1"># Set up mu_prior</span>

                <span class="k">if</span> <span class="n">readjust_sigma_prior</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Readjusting the prior for Inv-Gamma for sigma^2.&quot;</span><span class="p">)</span>
                    <span class="c1"># these values are the mean/variance of sigma^2: Inv-Gamma(*,*)</span>
                    <span class="n">sigma_squared_distribution_mean</span> <span class="o">=</span> <span class="n">_BayesianLinReg</span><span class="o">.</span><span class="n">_residual_variance</span><span class="p">(</span>
                        <span class="n">time</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span>
                    <span class="p">)</span>
                    <span class="n">sigma_squared_distribution_variance</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># TODO: we don&#39;t really know what the variance of sigma^2: Inv-Gamma(a, b) should be</span>

                    <span class="c1"># The following values are computed from https://reference.wolfram.com/language/ref/InverseGammaDistribution.html</span>
                    <span class="c1"># We want to match the mean of Inv-Gamma(a, b) to the sigma^2 mean (called mu), and variances together too (called var).</span>
                    <span class="c1"># We obtain mu = b / (a-1) and var = b^2 / ((a-2) * (a-1)^2) and then we simply solve for a and b.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">a_0</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="p">(</span>
                        <span class="n">sigma_squared_distribution_mean</span>
                        <span class="o">/</span> <span class="n">sigma_squared_distribution_variance</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">b_0</span> <span class="o">=</span> <span class="n">sigma_squared_distribution_mean</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mu_prior</span> <span class="o">=</span> <span class="n">mu_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No data provided -- reverting to default mu_prior.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu_prior</span> <span class="o">=</span> <span class="n">mu_prior</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Obtained mu_prior: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_prior</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Obtained a_0, b_0 values of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">a_0</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">b_0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_regression_prior</span><span class="p">:</span>
            <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mu_prior</span><span class="p">)</span>
            <span class="n">_BayesianLinReg</span><span class="o">.</span><span class="n">_plot_regression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_vals</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_plot_regression</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_residual_variance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">predictions</span> <span class="o">=</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">predictions</span> <span class="o">-</span> <span class="n">y</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">residuals</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sample_bayesian_linreg</span><span class="p">(</span><span class="n">mu_n</span><span class="p">,</span> <span class="n">lambda_n</span><span class="p">,</span> <span class="n">a_n</span><span class="p">,</span> <span class="n">b_n</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">):</span>

        <span class="c1">#this is to make sure the results are consistent</span>
        <span class="c1"># and tests don&#39;t break randomly</span>
        <span class="n">seed_value</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed_value</span><span class="p">)</span>

        <span class="n">sample_sigma_squared</span> <span class="o">=</span> <span class="n">invgamma</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">a_n</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">b_n</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Sample a beta value from Normal(mu_n, sigma^2 * inv(lambda_n))</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">mu_n</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Expected 1 dimensional mu_n, but got </span><span class="si">{</span><span class="n">mu_n</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">all_beta_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
            <span class="n">mu_n</span><span class="p">,</span> <span class="n">sample_sigma_squared</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lambda_n</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">all_beta_samples</span><span class="p">,</span> <span class="n">sample_sigma_squared</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_compute_bayesian_likelihood</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">sigma_squared</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">bayesian_likelihoods</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">prediction</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma_squared</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">bayesian_likelihoods</span><span class="p">,</span> <span class="n">prediction</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sample_likelihood</span><span class="p">(</span><span class="n">mu_n</span><span class="p">,</span> <span class="n">lambda_n</span><span class="p">,</span> <span class="n">a_n</span><span class="p">,</span> <span class="n">b_n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">):</span>
        <span class="n">all_sample_betas</span><span class="p">,</span> <span class="n">sample_sigma_squared</span> <span class="o">=</span> <span class="n">_BayesianLinReg</span><span class="o">.</span><span class="n">_sample_bayesian_linreg</span><span class="p">(</span>
            <span class="n">mu_n</span><span class="p">,</span> <span class="n">lambda_n</span><span class="p">,</span> <span class="n">a_n</span><span class="p">,</span> <span class="n">b_n</span><span class="p">,</span> <span class="n">num_samples</span>
        <span class="p">)</span>

        <span class="n">bayesian_likelihoods</span><span class="p">,</span> <span class="n">prediction</span> <span class="o">=</span> <span class="n">_BayesianLinReg</span><span class="o">.</span><span class="n">_compute_bayesian_likelihood</span><span class="p">(</span>
            <span class="n">all_sample_betas</span><span class="p">,</span> <span class="n">sample_sigma_squared</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">bayesian_likelihoods</span><span class="p">,</span> <span class="n">prediction</span><span class="p">,</span> <span class="n">sample_sigma_squared</span>

    <span class="k">def</span> <span class="nf">pred_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Predictive probability of a new data point</span>

<span class="sd">        Args:</span>
<span class="sd">            t: time</span>
<span class="sd">            x: the new data point</span>

<span class="sd">        Returns:</span>
<span class="sd">            pred_arr: Array with log predictive probabilities for each starting point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: use better priors</span>
        <span class="k">def</span> <span class="nf">log_post_pred</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">rl</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">x_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="n">rl</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">N</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">y_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="n">rl</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">xtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x_arr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">x_arr</span><span class="p">)</span>  <span class="c1"># computes X^T X</span>
            <span class="n">xty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x_arr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">y_arr</span><span class="p">))</span>  <span class="c1"># computes X^T Y</span>
            <span class="n">yty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">y_arr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">y_arr</span><span class="p">)</span>  <span class="c1"># computes Y^T Y</span>

            <span class="c1"># Bayesian learning update</span>

            <span class="n">lambda_n</span> <span class="o">=</span> <span class="n">xtx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_prior</span>
            <span class="n">mu_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lambda_n</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambda_prior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_prior</span><span class="p">)</span> <span class="o">+</span> <span class="n">xty</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="n">a_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_0</span> <span class="o">+</span> <span class="n">t</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">mu_prec_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_prior</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_prior</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_prior</span>
            <span class="p">)</span>
            <span class="n">mu_prec_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">mu_n</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">lambda_n</span><span class="p">),</span> <span class="n">mu_n</span><span class="p">)</span>
            <span class="n">b_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_0</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">yty</span> <span class="o">+</span> <span class="n">mu_prec_prior</span> <span class="o">-</span> <span class="n">mu_prec_n</span><span class="p">)</span>


            <span class="k">if</span> <span class="p">(</span><span class="n">a_n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b_n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    Got nonpositive parameters for Inv-Gamma: </span><span class="si">{</span><span class="n">a_n</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">b_n</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">                    Likely, integer overflow -- maybe scale down the data?</span>
<span class="s2">                    &quot;&quot;&quot;</span>
                <span class="p">)</span>
            <span class="c1"># cannot allow this to fail arbitrarily, so falling back to prior</span>
            <span class="k">if</span> <span class="n">a_n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">a_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_0</span>
            <span class="k">if</span> <span class="n">b_n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">b_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_0</span>

            <span class="c1"># Compute likelihood of new point x under new Bayesian parameters</span>

            <span class="n">x_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">indiv_likelihoods</span><span class="p">,</span> <span class="n">prediction</span><span class="p">,</span> <span class="n">var_pred</span> <span class="o">=</span> <span class="n">_BayesianLinReg</span><span class="o">.</span><span class="n">_sample_likelihood</span><span class="p">(</span>
                <span class="n">mu_n</span><span class="p">,</span> <span class="n">lambda_n</span><span class="p">,</span> <span class="n">a_n</span><span class="p">,</span> <span class="n">b_n</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_likelihood_samples</span>
            <span class="p">)</span>

            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indiv_likelihoods</span><span class="p">)</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">likelihoods</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sum_samples</span><span class="p">)</span>
            <span class="n">avg_likelihood</span> <span class="o">=</span> <span class="n">likelihoods</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_likelihood_samples</span>

            <span class="n">mean_prediction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">prediction</span><span class="p">)</span>
            <span class="n">std_prediction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_pred</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_prediction</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">std_prediction</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">avg_likelihood</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="o">%</span> <span class="mi">50</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># put 1 because then t=1 will show up</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running Bayesian Linear Regression with t=</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># initialize empty mean and std deviation arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">pred_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">log_post_pred</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">rl</span><span class="o">=</span><span class="n">rl</span><span class="p">)</span> <span class="k">for</span> <span class="n">rl</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">pred_arr</span>

    <span class="c1"># pyre-fixme[15]: `pred_mean` overrides method defined in `_PredictiveModel`</span>
    <span class="c1">#  inconsistently.</span>
    <span class="k">def</span> <span class="nf">pred_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Predicted mean at the next time point.</span>

<span class="sd">        Args:</span>
<span class="sd">            t: time.</span>
<span class="sd">            x: the new data point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            meant_arr[t]: mean value predicted at the next data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

    <span class="c1"># pyre-fixme[15]: `pred_std` overrides method defined in `_PredictiveModel`</span>
    <span class="c1">#  inconsistently.</span>
    <span class="k">def</span> <span class="nf">pred_std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        predicted standard deviation at the next time point.</span>
<span class="sd">        Args:</span>
<span class="sd">            t: time.</span>
<span class="sd">            x: the new data point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            std_arr[t]: predicted std. dev at the next point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update_sufficient_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Updates sufficient statistics.</span>

<span class="sd">        Updates the sufficient statistics for posterior calculation,</span>
<span class="sd">        based on the new data point.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: the new data point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">current_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">current_t</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">current_t</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">,</span> <span class="n">new_x</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">]))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_multivariate</span><span class="p">():</span>
        <span class="c1"># This class hasn&#39;t been confirmed / checked / tested</span>
        <span class="c1"># we assume NO for now.</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">_PoissonProcessModel</span><span class="p">(</span><span class="n">_PredictiveModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;BOCPD Predictive model, where data comes from Poisson.</span>

<span class="sd">    Predictive model, which assumes that the data</span>
<span class="sd">    comes from a Poisson distribution. We use a</span>
<span class="sd">    gamma distribution as a prior on the poisson rate parameter.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        data: TimeSeriesData object, on which algorithm is run.</span>
<span class="sd">        parameters: Specifying all the priors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">TimeSeriesData</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">PoissonModelParameters</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_alpha</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">alpha_prior</span>  <span class="c1"># prior for rate lambda ~ Gamma(alpha, beta)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_beta</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">beta_prior</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># everything is already set up in __init__!</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">pred_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>  <span class="c1"># predict the probability that time t, we have value x</span>
        <span class="sd">&quot;&quot;&quot;Predictive log probability of a new data point.</span>

<span class="sd">        Args:</span>
<span class="sd">            t: time.</span>
<span class="sd">            x: the new data point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            probs: array of log probabilities, for each starting point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">probs</span> <span class="o">=</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">probs</span>

    <span class="k">def</span> <span class="nf">pred_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predicted mean at the next time point.</span>

<span class="sd">        Args:</span>
<span class="sd">            t: time.</span>
<span class="sd">            x: the new data point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            mean_arr[t]: mean predicted value at the next point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">pred_std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predicted std dev  at the next time point.</span>

<span class="sd">        Args:</span>
<span class="sd">            t: time.</span>
<span class="sd">            x: the new data point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            std_arr[t]: std. deviation of the prediction at the next point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update_sufficient_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates sufficient statistics.</span>

<span class="sd">        Updates the sufficient statistics for posterior calculation,</span>
<span class="sd">        based on the new data point.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: the new data point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_n</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_p</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_mean_arr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_std_arr</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="n">num_events_before</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># t is the number of previous events we consider to adjust poisson rate</span>
            <span class="n">num_events_before</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># adjust our posterior distribution</span>
            <span class="c1"># these values are calculated from matching the mean and std deviation of the negative binomial</span>
            <span class="c1"># to the equation on page 4 of http://people.stat.sc.edu/Hitchcock/stat535slidesday18.pdf</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_alpha</span> <span class="o">+</span> <span class="n">num_events_before</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_beta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_beta</span><span class="p">)</span>

            <span class="n">new_n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">new_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

            <span class="n">new_mean_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbinom</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>  <span class="c1"># the mean is n * (1-p) / p</span>
            <span class="n">new_std_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbinom</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>  <span class="c1"># the std deviation is np.sqrt(n * (1-p)) / p</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mean_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_mean_arr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_std_arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_std_arr</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_multivariate</span><span class="p">():</span>
        <span class="c1"># This class hasn&#39;t been confirmed / checked / tested</span>
        <span class="c1"># we assume NO for now.</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

          </div>
          
        </div>
      </div>
</div>
<footer class="footer">
    <div class="container">
        <div class="row footer__links">
            <div class="col footer__col">
                <div class="footer__title">Links</div>
                <ul class="footer__items">
                    <li class="footer__item">
                        <a href="https://github.com/facebookresearch/Kats" target="_blank" rel="noopener noreferrer" class="footer__link-item">Kats@GitHub</a>
                    </li>
                </ul>
            </div>
            <div class="col footer__col">
                <div class="footer__title">Legal</div>
                <ul class="footer__items">
                    <li class="footer__item">
                        <a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noreferrer noopener" class="footer__link-item">Privacy</a>
                    </li>
                    <li class="footer__item">
                        <a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noreferrer noopener" class="footer__link-item">Terms</a>
                    </li>
                    <li class="footer__item">
                        <a href="https://opensource.facebook.com/legal/cookie-policy" target="_blank" rel="noreferrer noopener" class="footer__link-item">Cookies</a>
                    </li>
                </ul>
            </div>
        </div>
        <div class="footer__bottom text--center">
            <div class="margin-bottom--sm">
                <img src="https://docusaurus.io/img/oss_logo.png" alt="Facebook Open Source Logo" class="themedImage_1VuW themedImage--light_3UqQ footer__logo"/>
                <img src="https://docusaurus.io/img/oss_logo.png" alt="Facebook Open Source Logo" class="themedImage_1VuW themedImage--dark_hz6m footer__logo"/>
            </div>
            <div class="footer__copyright">Copyright Â© 2021 Facebook, Inc.</div>
        </div>
    </div>
</footer>
<!--
</div>
<script src="/Kats/assets/js/runtime~main.9e005abd.js"></script>
<script src="/Kats/assets/js/main.6382ca5e.js"></script>
-->

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Kats</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../kats.consts.html">kats.consts module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kats.detectors.html">kats.detectors package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kats.graphics.html">kats.graphics package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kats.models.html">kats.models package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kats.tsfeatures.html">kats.tsfeatures package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kats.utils.html">kats.utils package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
      
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>